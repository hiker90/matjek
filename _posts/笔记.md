> 你不知道的JavaScript

# 一、作用域和闭包

## 1、作用域

  ### 1.1 分词、解析（代码 => AST => 可执行代码）
  ### 1.2 作用域

    - LHS：赋值；RHS：查值
    - 声明在前，赋值在后
    - 同作用域下已存在声明过的变量，忽略后续声明
    - 沿作用域链向上查找变量，找不到抛出异常
    - 全局作用域中也无法找到变量，会在全局作用于创建一个同名变量
    - ReferenceError：作用域链内找不到变量
    - TypeError：作用域判别成功，但操作不合法（如对非函数类型值进行函数调用操作）
    - 不成功的RHS 引用会导致抛出ReferenceError 异常。不成功的LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS 引用的目标作为标识符，或者抛出ReferenceError 异常（严格模式下）

## 2、词法作用域

  - 词法作用域都只由函数被声明时所处的位置决定
  - eval()、with() 欺骗词法；欺骗词法作用域会导致性能下降

## 3、函数作用域和块作用域

  - try/catch中的catch分句；
  - let/const

## 4、提升

  - 声明提前，原地赋值
  - 函数声明优先

## 5、闭包

  - 函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包
  - 模块的两个特征：
    1. 为创建内部作用域而调用了一个包装函数
    2. 包装函数的返回值必须至少包括一个对内部函数的引用

# 二、this和对象原型

  - this既不指向函数自身，也不指向函数的词法作用域；是在函数调用时发生的绑定；
  - 判断this指向
    1. 默认绑定：直接调用，默认绑定全局；
    2. 隐式绑定：函数方法的引用；函数作为参数传递
    3. 显式绑定：call、apply、bind
    4. new 绑定
  - 优先级：
    1. 先判断是不是new；
    2. 是否存在显式绑定；
    3. 是否存在隐式绑定；
    4. 以上都没有，默认绑定。
  - new方法执行过程：
    - 创建一个新对象
    - 对新对象执行[[原型]]链接
    - 新对象绑定到函数调用的this
    - 如果函数没有返回其他对象，自动返回新创建的对象
  - bind 创建偏函数

# 三、对象

  - Object.preventExtensions()
  - Object.seal()
  - Object.freeze()

# 四、类

  - 类意味着复制；传统的类被实例化时，它的行为会被复制到实例中；类被继承时，行为也会被复制到子类中
  - 多态（在继承链的不同层次名称相同但是功能不通的函数）本质上引用是复制的结果

# 五、原型

  - [[Get]]操作会查找对象内部[[prototype]]关联的对象，并在原型链上遍历；终点是Object.prototype
  - 继承不会复制，只是通过[[prototype]]关联
  - new函数是创建一个新对象，将它的prototype属性关联到“其他对象”

# 六、行为委托

  使用Object.create()委托，创建兄弟对象间的委托关系
